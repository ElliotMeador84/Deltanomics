---
title: U.S. Food Deserts
author: ''
date: '2020-07-29'
slug: food-deserts-data-clean-merge
categories:
  - R
  - Rural
tags:
  - Data
  - dplyr
  - ggplot
subtitle: ''
summary: ''
authors: []
lastmod: '2020-07-29T23:11:33+01:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
editor_options: 
  chunk_output_type: console
---

# Introduction
A huge issue today related to food and rural population research are food deserts. 
Food deserts are a complicated issue, but the idea centres on a simple premise: areas, where it's hard to reach a grocery store or access food, can be thought of as food deserts. 
If you're interested in knowing more about the discourse on food deserts, than I'd recommend looking into these papers: 

We'll use a custom theme for `ggplot2` plots made with this code. 
Note the `...` notation, which allows us to make on-the-fly changes without calling another `theme` argument. 

```{r, echo=F}
options(warn = -1)
```

```{r}
post_theme <- function(...) {
  theme(
    text = 
      element_text(
        color = 'black',
         family = 'serif'),
    axis.text = 
      element_text(
        color = 'black', 
        size = 12.5),
    panel.background = 
      element_blank(),
    axis.line.x = 
      element_line(
        color = 'black'),
    axis.ticks = element_blank(),
    plot.margin = margin(.75, .75, .75, .75, 'cm'),
    plot.caption = 
      element_text(hjust = 0,
                                face = "italic"),
    plot.title = 
      element_text(
        face = 'bold'),
    plot.subtitle = 
      element_text(face = 'bold'),
    plot.title.position = "plot",
    plot.caption.position =  "plot", 
    strip.background = 
      element_blank(), 
    strip.text = 
      element_text(
        face = 'bold')
  ) +
    theme(...) # this bit allows us to make changes using this same function instead of calling two theme functions.
}
```


# The data
Data for this post is on food deserts and comes from Kaggle. Kaggle is a great resource for aspiring data scientists and experienced ones. 
Specifically, the page called [Food Deserts in the US: Food access for sub-populations of the United States](https://www.kaggle.com/tcrammond/food-access-and-food-deserts?select=food_access_variable_lookup.csv).
You can download the data directly from the link in the sentence above. 
The code below reads in the data. 

```{r, message=F}
library(tidyverse)
library(janitor)
library(knitr)
library(kableExtra)
library(glue)
library(tidytext)
library(scales)

# For mapping and census data
library(tigris)
library(leaflet)


# File 1
food_access_research_atlas <- 
  read_csv('~/Downloads/665808_1173338_bundle_archive/food_access_research_atlas.csv') %>% 
  clean_names()

# File 2
lookup <- 
  read_csv('~/Downloads/665808_1173338_bundle_archive/food_access_variable_lookup.csv') %>% 
  clean_names()

# Pull in the USDA data from a directory I created in my cloud storage.
rural_urban <-
  read_csv('~/OneDrive - SRUC/Data/usda/ruralurbancodes2013.csv') %>%
  select(state, 
         county = county_name,
         rucc_2013,
         desc = description)
```

```{r hidden_scratch, echo=F}
food_access_research_atlas_names <- names(food_access_research_atlas)
```

An interesting caveat with the data is that it comes in two files. 
One file is the data, and the other file is what's known as a data dictionary or data lookup. 
The lookup file is a database that explains what each variable is. 
 
## Linking with rural-urban classification data
There isn't a really good indicator of rural/urban classification in the data, so, as usual, we'll need to add one. 
I've used the USDA Rural-Urban Classifications before in the post on [Covid-19 and Rural Areas in the U.S.](https://www.thedeltanomics.com/post/covid-19-rural-deltanomics/). 

```{r}

clean_names <- 
  function(x){
    x <- str_to_lower(x)
    x <- str_remove_all(x, 'county')
    x <- str_remove_all(x, '[[:digit:]]')
    x <- str_squish(x)
    x <- str_trim(x)
    x
  }


rural_urban <- 
  rural_urban %>% 
  mutate(county = clean_names(county)) %>% 
  rename(abb = state) %>% 
  left_join(
tibble(abb = state.abb, 
       state = clean_names(state.name))) %>% 
  mutate(state_county = 
           glue('{state} {county}')) %>% 
  select(state_county, rucc_2013, desc)
  


rural_food_desert <- 
  food_access_research_atlas %>% 
  mutate(state = clean_names(state),
            county = clean_names(county),
            state_county = 
                  glue('{state} {county}')) %>% 
  left_join(rural_urban, 
            by = 'state_county') %>% 
  filter(str_detect(desc, 'rural'))


```

# Working with lookup files - A closer look at SNAP
Lookup files are often called *data dictionaries*.
Data dictionaries are a common component of many large datasets that are widely publically used.
As previously mentioned, quite often, a data dictionary or lookup is just another file that accompanies the primary data. 

It isn't "data" is the traditional sense (i.e. we aren't going to be performing cross-tabulations on it anytime soon.), but it is a useful approach to treat it just as any other data file.
For instance: 

1. We can append data dictionaries/lookups to the central database as we did previously. 
2. We can use natural language processing on the data dictionaries to get a better understanding of the data holds; and, 
3. We can use data tools like `dplyr` and `purrr` to pick apart the lookup file and make it more manageable.  

Let's say we are interested in looking at SNAP. 
SNAP is short for *Supplemental Nutrition Assistance Program*. 
According to the [USDA's website](https://www.fns.usda.gov/snap/supplemental-nutrition-assistance-program):

> SNAP provides nutrition benefits to supplement the food budget of needy families so they can purchase healthy food and move towards self-sufficiency.

We can use `dplyr` and the `kable` function from `knitr` to quickly search and display the results for variables on SNAP. 
```{r}
lookup %>% 
  filter(str_detect(description, 'SNAP')) %>% 
  mutate(long_name = 
           str_trunc(long_name, 10)) %>% 
  kable(format = 'html', booktab = T) %>% 
  kable_styling()
```

Glancing at the table above, there appear to be nine variables that cover SNAP benefits. 
Also, it appears that SNAP variables are often distinguished by have either *number* or *share*, which means that the variable has either total counts of percents of occurrence. 

Let's take a look at some and compare them by state. 
We'll use the verb `contains` within `dyplyr` to grab variables contain *SNAP*. 

```{r}
rural_food_desert_snap <- 
  rural_food_desert %>% 
  select(state, county, desc, census_tract,
         contains('snap')) 
  
```


# Travel distance and rural-urban SNAP
Now that we have our data in a way that we like it let's do some quick plots, first looking at state and county levels, then looking at rural-urban areas. 

## Travel distance
```{r}
county_snap_dist <-
  rural_food_desert_snap %>% 
  mutate(id = group_indices(., census_tract)) %>% 
  select(state, county, desc, census_tract,contains('share')) %>% 
  pivot_longer(-c(state, 
                  county, 
                  desc, 
                  census_tract),
               names_to =  'snap_dist', 
               values_to = 'rate') %>% 
  mutate(snap_dist = 
           parse_number(snap_dist), 
         snap_dist = 
           replace_na(snap_dist, .5)) 

```

Let's quickly take a look at the top rate (percent) of people in census tracts for each distance from a grocery store. 
We'll look at only those people classified as living in rural counties. 

The plot below is a boxplot that shows the spread of rate SNAP recievers accross distances to supermarkets. 
It shows that there is a great deal of variability in terms of distance as well as a high number of people who have to travel quite far. 
The rate of SNAP recievers appears to be negatively correlated with distance, meaning that the rate of SNAP recievers decreases as distance increases. 
```{r}

county_snap_dist %>%
  ggplot(aes(as.factor(snap_dist),rate))+
  geom_boxplot(aes(fill = as.factor(snap_dist)), 
               show.legend = F)+
  scale_fill_viridis_d(direction = -1)+
  scale_y_continuous(labels = percent)+
  post_theme(
    axis.title.x = 
      element_text(face = 'italic'),
             axis.title.y = 
               element_text(angle = 0, 
                            hjust= 1, 
                            face = 'italic'))+
  labs(title = 'Relationship between percent of SNAP recievers and food deserts',
       subtitle = 'Rural and Remote areas in the US according to USDA classification',
       x = 'Miles to nearest supermarket',
       y = 'Percent recieving\nSNAP')+
  annotate('rect', xmin = 3.9, xmax = 4.1, ymin = .1, ymax = .35, color = '#C4C4C4', alpha = .25)+
  annotate('text', x = 3.65, y = .425, label = str_wrap('Upwards of 35% of residents in these census tract travel 20 or miles to a grocery store and recive government food benefits.', 30), hjust= .5, size = 2.5)+
  annotate('segment', 
           x  = 3.85, 
           xend = 4, 
           y = .385, 
           yend = .36, 
           arrow = arrow(type = 'closed', 
                         length = unit(1, 'mm')))
```

# A closer look with Leaflet
Our data is aggregated by census tract and is therefore geographical by nature. 
Mapping in R has made huge developments in the past 5 to 10 years, and any work with rural/urban analysis can usually be benefited through some geo-spatial analysis. 
So learning to make maps is always helpful!

## Leaflet maps
The `leaflet` package is a fantastic way to make interative maps with a relatively small amount of code. 
It works really well will with the `sf` package for geocomputional analysis. 
In addition, we can use the `tigris` package to get census tract information straight in R. 
`tigris` can return `sf` objects, making for speedy workflow between the three packages. 

Below, we'll take a look those census tracts that have a large proportion of the population that have to travel 20 or miles to a supermarket and that have a high percentage of SNAP recipients. 
```{r, include=F}

## Get the top 25 of rate
top_5_perc_20m <- 
  county_snap_dist %>% 
  filter(snap_dist == 20) %>% 
  top_n(25, rate) 

top_5_perc_20m_ls <- 
  top_5_perc_20m %>% 
  mutate(id = LETTERS[1:nrow(.)]) %>% 
  split(.$id)
  


top_5_20_sf_ls <- 
  map(top_5_perc_20m_ls, 
    possibly(function(x){
      tracts(state = x$state, 
             county = x$county, 
             cb = T)
    }, NULL)) 

## need to find matches here
top_5_20_sf_ls$A %>% 
  as_tibble() %>% 
  mutate(leng = str_length(AFFGEOID)) %>% 
  pull(leng)

top_5_perc_20m %>% 
  mutate(leng = str_length(census_tract)) %>% 
  pull(leng)



map(top_5_20_sf_ls, function(x){
  x %>% 
    as_tibble() 
  # %>% 
  #   left_join(top_5_perc_20m, 
  #             by = c('census_tract' = 
  #                      'TRACTCE'))
})


```











