<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rural | Deltanomics</title>
    <link>/categories/rural/</link>
      <atom:link href="/categories/rural/index.xml" rel="self" type="application/rss+xml" />
    <description>Rural</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>©2020</copyright><lastBuildDate>Sun, 08 Nov 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/images/icon_hu92a9dc9639b79cadf266306904fb01f6_516996_512x512_fill_lanczos_center_2.png</url>
      <title>Rural</title>
      <link>/categories/rural/</link>
    </image>
    
    <item>
      <title>US 2020 Presidental Election and Rural - Urban Divide</title>
      <link>/post/us-2020-presidental-election-and-rural-urban-divide/</link>
      <pubDate>Sun, 08 Nov 2020 00:00:00 +0000</pubDate>
      <guid>/post/us-2020-presidental-election-and-rural-urban-divide/</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;/rmarkdown-libs/anchor-sections/anchor-sections.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;/rmarkdown-libs/anchor-sections/anchor-sections.js&#34;&gt;&lt;/script&gt;


&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;The US Presidential vote count has nearly finished.
Trump is fighting the results in court though appears to have lost, but a clear theme that’s coming out is the contrast of rural and urban voters.
The theory seems to go: Trump voters for the most part come from rural areas, and the election is based on a rural vs urban debate.
We can test this theory using some data science approaches - mainly, cleaning and merging data from several places into a useful format.
For this post, we’ll be addressing the research question:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Did Trump’s backing come from only rural areas and could it swing the election in his or future candidates favour?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let’s first load our libraries and get started!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# For data wrangling/tables
library(tidyverse)
library(lubridate)
library(ggtext)
library(glue)
library(scales)
library(RColorBrewer)

# For mapping and census data
library(tigris)
library(leaflet)
library(leaflet.extras)
library(maps)
library(sf)
library(widgetframe)
library(htmlwidgets)
library(htmltools)
map &amp;lt;- purrr::map&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As always I like to use a custom &lt;code&gt;ggplot&lt;/code&gt; function specified below.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# a custom theme for ggplots
post_theme &amp;lt;- function(...) {
  theme(
    text = 
      element_text(
        color = &amp;#39;black&amp;#39;,
         family = &amp;#39;serif&amp;#39;),
    axis.text = 
      element_text(
        color = &amp;#39;black&amp;#39;, 
        size = 14),
    panel.background = 
      element_blank(),
    axis.line.x = 
      element_line(
        color = &amp;#39;black&amp;#39;),
    axis.ticks = element_blank(),
    plot.margin = margin(.75, .75, .75, .75, &amp;#39;cm&amp;#39;),
    plot.caption = 
      element_text(hjust = 0,
                   size = 15,
                                face = &amp;quot;italic&amp;quot;),
    plot.title = 
      element_text(
        face = &amp;#39;bold&amp;#39;),
    plot.subtitle = 
      element_text(face = &amp;#39;bold&amp;#39;),
    plot.title.position = &amp;quot;plot&amp;quot;,
    plot.caption.position =  &amp;quot;plot&amp;quot;, 
    strip.background = 
      element_blank(), 
    strip.text = 
      element_text(
        face = &amp;#39;bold&amp;#39;)
  ) +
    theme(...) # this bit allows us to make changes using this same function instead of calling two theme functions.
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;the-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;The data&lt;/h1&gt;
&lt;p&gt;Our process for analysis is a two-step process: first, we download and tidy data for the US 2020 presidential election results; then, we’ll join this data to the USDA Rural-Urban classifications. The resulting database will be used to investigate voting patterns between these classifications.&lt;/p&gt;
&lt;div id=&#34;election-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Election data&lt;/h2&gt;
&lt;p&gt;Election data comes from Fabio Votta’s Github page, under the repository for &lt;em&gt;favstats/USElection2020-NYT-Results&lt;/em&gt; (visit &lt;a href=&#34;https://github.com/favstats/USElection2020-NYT-Results&#34; class=&#34;uri&#34;&gt;https://github.com/favstats/USElection2020-NYT-Results&lt;/a&gt;). Fabio is a fantastic political data scientist. I’d recommend following him on Twitter (&lt;span class=&#34;citation&#34;&gt;@favstats&lt;/span&gt;) as he shares a lot of great information on his work there. Fabio wrote a function that communicates with the New York Times data API to pull the data in a tidy format.&lt;/p&gt;
&lt;p&gt;I’ve already cloned into the &lt;em&gt;favstats/USElection2020-NYT-Results&lt;/em&gt; repository and have the database of voting trends on my laptop. This repo has dated files with the election results as they come in. We’ll need a bit of code to help us identify the most recent version as it’s being updated. Below, is the code I used to input the data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data_folders &amp;lt;- list.files(&amp;#39;~/Documents/R/USElection2020-NYT-Results/data/&amp;#39;)

max_date_folder &amp;lt;- data_folders %&amp;gt;% 
  str_subset(&amp;#39;^2020&amp;#39;) %&amp;gt;% 
  max() 

results_2020 &amp;lt;- glue(&amp;#39;~/Documents/R/USElection2020-NYT-Results/data/{max_date_folder}&amp;#39;) %&amp;gt;% 
  list.files(full.names = T) %&amp;gt;% 
  str_subset(&amp;#39;presidential$&amp;#39;) %&amp;gt;% 
  list.files(full.names = T) %&amp;gt;% 
  str_subset(&amp;#39;.csv$&amp;#39;) %&amp;gt;% 
  read_csv()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;usda-rural-urban-classifications&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;USDA Rural-Urban Classifications&lt;/h2&gt;
&lt;p&gt;The USDA’s Rural-Urban Classification’s classify each US county along a rural-urban continuum. We’ve used these codes quite a lot when dealing with US county-level data. You can find this data here for download, &lt;a href=&#34;https://www.ers.usda.gov/data-products/rural-urban-continuum-codes.aspx&#34; class=&#34;uri&#34;&gt;https://www.ers.usda.gov/data-products/rural-urban-continuum-codes.aspx&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In addition, we’re going to use a few of R’s internal databases to help us out in the wrangling process, specifically we’ll use some data from the &lt;code&gt;tigris&lt;/code&gt; package.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In the process of writing this blog post I’ve discovered that Alaska uses electoral districts for counting votes - not counties. Therefore, for now, we’re going to leave Alaska out of the analysis because assigning a rural-urban code to electoral districts requires quite a bit of GIS work that’s outwith the scope of this post.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# US county fips from tigris package
fips_codes &amp;lt;-
  fips_codes %&amp;gt;% 
  as_tibble()


# Pull in the USDA data from a directory I created in my cloud storage.
rural_urban &amp;lt;-
  read_csv(
    &amp;#39;~/OneDrive - SRUC/Data/usda/ruralurbancodes2013.csv&amp;#39;
    ) %&amp;gt;%
  as_tibble() %&amp;gt;% 
  select(state, 
         county = county_name,
         rucc_2013,
         desc = description)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;data-join&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Data join&lt;/h2&gt;
&lt;p&gt;We need to join the election data, which has the county fips codes to identify each county, with the built-in &lt;code&gt;county.fips&lt;/code&gt; database. Then, we have to join the election data with the new &lt;code&gt;rural_urban_tidy&lt;/code&gt; data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# clean names will be used to help get joining data in format that will merge well
clean_names &amp;lt;- 
  function(x){
    x &amp;lt;- str_to_lower(x)
    x &amp;lt;- str_remove_all(x, &amp;#39;county&amp;#39;)
    x &amp;lt;- str_remove_all(x, &amp;#39;[[:digit:]]&amp;#39;)
    x &amp;lt;- str_squish(x)
    x &amp;lt;- str_trim(x)
    x
  }


fips_codes_tidy &amp;lt;- fips_codes %&amp;gt;% 
  mutate(county = clean_names(county)) %&amp;gt;% 
  mutate(fips = glue(&amp;#39;{state_code}{county_code}&amp;#39;))


rural_urban_tidy &amp;lt;- rural_urban %&amp;gt;% 
  mutate(county = clean_names(county)) %&amp;gt;% 
  left_join(fips_codes_tidy, 
            by = c(&amp;#39;state&amp;#39;, 
                   &amp;#39;county&amp;#39;)) %&amp;gt;% 
  select(fips, 
         county, 
         state = state_name, 
         ru_ur_n = rucc_2013,
         ru_ur_label = desc)
  
  

results_2020_rural_urban &amp;lt;- 
  results_2020 %&amp;gt;%
  inner_join(rural_urban_tidy %&amp;gt;% 
               select(-state), 
             by = &amp;#39;fips&amp;#39;) &lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;tidy-and-combine&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Tidy and combine&lt;/h1&gt;
&lt;p&gt;We now have two datasets to work with:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Our dataset containing the voting outcome&lt;/li&gt;
&lt;li&gt;Our dataset with the rural-urban codes&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We’re going to transform our voting data to tidy format so we can join it with the rural-urban data.
During this process we’ll also make some adjustments to what will become our axis labels. Adding two asterisks (**) will signal the &lt;code&gt;ggtext&lt;/code&gt; package to bold certian words in the &lt;code&gt;ggplot&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ru_ur_partison_vote &amp;lt;- 
  results_2020_rural_urban %&amp;gt;% 
  select(ru_ur_label,
         ru_ur_n,
         results_bidenj, 
         results_trumpd) %&amp;gt;% 
  gather(key, partison_vote, 
         -ru_ur_label, -ru_ur_n) %&amp;gt;% 
  group_by(ru_ur_label) %&amp;gt;% 
  mutate(total_ru_ur_vote = sum(partison_vote), 
         key = str_remove_all(key, &amp;#39;results_&amp;#39;)
         ) %&amp;gt;% 
  ungroup() 


ru_ur_new_v &amp;lt;- c(&amp;quot;**Urban** population of 2,500 to 19,999, not adjacent to a metro area&amp;quot;, &amp;quot;**Urban** population of 2,500 to 19,999, adjacent to a metro area&amp;quot;, &amp;quot;**Urban** population of 20,000 or more, not adjacent to a metro area&amp;quot;, &amp;quot;Counties in **metro** areas of 250,000 to 1 million population&amp;quot;, &amp;quot;Counties in **metro** areas of fewer than 250,000 population&amp;quot;, &amp;quot;Counties in **metro** areas of 1 million population or more&amp;quot;, &amp;quot;Completely **rural** or less than 2,500 urban population, adjacent to a metro area&amp;quot;, &amp;quot;Completely **rural** or less than 2,500 urban population, not adjacent to a metro area&amp;quot;, &amp;quot;**Urban** population of 20,000 or more, adjacent to a metro area&amp;quot;) %&amp;gt;% 
  str_replace_all(&amp;#39;, not&amp;#39;, &amp;#39;&amp;lt;br&amp;gt; not&amp;#39;) %&amp;gt;% 
   str_replace_all(&amp;#39;, adjacent&amp;#39;, &amp;#39;&amp;lt;br&amp;gt; adjacent&amp;#39;)

ru_ur_partison_vote &amp;lt;- ru_ur_partison_vote %&amp;gt;% 
  distinct(ru_ur_label) %&amp;gt;% 
  mutate(ru_ur_label_new = ru_ur_new_v) %&amp;gt;% 
  right_join(ru_ur_partison_vote) %&amp;gt;% 
  select(ru_ur_label = ru_ur_label_new, 
         ru_ur_n, 
         key, 
         partison_vote, 
         total_ru_ur_vote)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;sub-setting-for-annotations&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Sub-setting for annotations&lt;/h2&gt;
&lt;p&gt;Adding annotations to a plot can really help drive home the main take-aways by drawing the reader’s eye to specific areas.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A key finding with our analysis, related to rural voting patterns, is that many people in urban areas voted Donald Trump.
And because the urban areas have such a higher percentage of people living there it is much more impactful on the election outcome than rural areas.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We’re going to highlight those urban vote percentages and add them to &lt;code&gt;geom_text&lt;/code&gt; in the &lt;code&gt;ggplot&lt;/code&gt; function.
We can specify a new data set in that geom (separate from the primary data that’s being plotted in the main call).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bar_labels_df &amp;lt;- ru_ur_partison_vote %&amp;gt;% 
  group_by(ru_ur_label, key) %&amp;gt;% 
  summarise(tot_ru_ur_party = 
           sum(partison_vote)) %&amp;gt;% 
  mutate(percent_ru_ur_party =  percent(tot_ru_ur_party/sum(tot_ru_ur_party))
         ) %&amp;gt;% 
  ungroup() %&amp;gt;% 
  mutate(position_y = tot_ru_ur_party/2, 
         position_done = ifelse(
           key == &amp;#39;bidenj&amp;#39;, position_y + lead(tot_ru_ur_party), position_y
         ))  %&amp;gt;% 
  group_by(ru_ur_label) %&amp;gt;% 
  mutate(tot = sum(tot_ru_ur_party)) %&amp;gt;% 
  ungroup()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our bar colours will split out by the proportion of a every level won by one of the two main candidates.&lt;/p&gt;
&lt;p&gt;I searched the web and found the Republican party red and Democratic party blue. You can see these colours below.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;show_col(c( &amp;#39;#0015BC&amp;#39;, &amp;#39;#DE0100&amp;#39;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-11-08-us-2020-presidental-election-and-rural-urban-divide.en_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;
We can use these unique colours in the &lt;code&gt;scale_fill_manual&lt;/code&gt; function.
Also, the &lt;code&gt;label_number_si&lt;/code&gt; function from the &lt;code&gt;scales&lt;/code&gt; package provides the clean looking axes labels.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# the scale_fill_manual requires a named vector, with the names corresponding to the levels to be filled
party_cols &amp;lt;- c( &amp;#39;#0015BC&amp;#39;, &amp;#39;#DE0100&amp;#39;)

names(party_cols) &amp;lt;- unique(ru_ur_partison_vote$key)
# for clean labels
gg_labs &amp;lt;- label_number_si(accuracy = 0.01)

gg_wrap &amp;lt;- function(width = 25){
  str_wrap(x, width)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;building-the-plot-by-layers&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Building the plot by layers&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;ggplot2&lt;/code&gt; works by layering geoms on top of one another. This works to our advantage, as we can step through each additional plot layer at a time.&lt;/p&gt;
&lt;p&gt;First, let’s create the base plot with data.
Note the use of &lt;code&gt;mutate&lt;/code&gt; and &lt;code&gt;fct_reorder&lt;/code&gt; to ensure our plot level order corresponds to the highest to lowest.
We’ll start with a simple bar plot.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(ru_ur_partison_vote_gg &amp;lt;- 
    ru_ur_partison_vote %&amp;gt;% 
  mutate(ru_ur_label = 
           fct_reorder(
             ru_ur_label,                 
             total_ru_ur_vote), 
         prefix = word(ru_ur_label, 1, 1)
         ) %&amp;gt;% 
  ggplot(aes(ru_ur_label, 
             partison_vote, 
             fill = key))+
  geom_col(show.legend = F))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-11-08-us-2020-presidental-election-and-rural-urban-divide.en_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The plot above shows we’re on the right track, but for the most part it’s unreadable at the moment.
Before flipping the coordinates, we’re going to add the annotations to the plot.
These are contained in the &lt;code&gt;bar_labels_df&lt;/code&gt; data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(ru_ur_partison_vote_gg &amp;lt;- 
  ru_ur_partison_vote_gg +
  geom_text(data = bar_labels_df %&amp;gt;%
              filter(str_detect(ru_ur_label, 
                                &amp;#39;^Counties&amp;#39;)) ,
            aes(x = ru_ur_label,
                y = position_done,
                label = percent_ru_ur_party),
            color = &amp;#39;white&amp;#39;)+
    geom_text(data  = bar_labels_df,
              aes(x = ru_ur_label, 
                  y = tot+1.5e5,
                  label = comma(tot)), 
                  hjust = 0,
              color = &amp;#39;black&amp;#39;,
              size = 3
              ))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-11-08-us-2020-presidental-election-and-rural-urban-divide.en_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now we add the &lt;em&gt;wow&lt;/em&gt; factor: the colours and label functions.
Also, the &lt;code&gt;coord_flip&lt;/code&gt; call flips the chart on its side - were we can more easily see everything.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(ru_ur_partison_vote_gg &amp;lt;- 
  ru_ur_partison_vote_gg  +
  scale_x_discrete(labels = function(x){str_wrap(x, 25)})+
  scale_y_continuous(labels = gg_labs)+
  scale_fill_manual(values = party_cols)+
  coord_flip(clip = &amp;#39;off&amp;#39;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-11-08-us-2020-presidental-election-and-rural-urban-divide.en_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;1056&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And finally, we add the a custom theme and some labels.
The &lt;code&gt;ggtext&lt;/code&gt; package controls are specified in the plot &lt;code&gt;theme&lt;/code&gt;.
We use the &lt;code&gt;element_markdown&lt;/code&gt; and the &lt;code&gt;element_textbox_simple&lt;/code&gt; to turn on the HTML and Markdown elements in the label text.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(ru_ur_partison_vote_gg &amp;lt;- 
  ru_ur_partison_vote_gg   +
    labs(
        title = &amp;quot;&amp;lt;b&amp;gt;**US 2020 Elections by Rural-Urban Classification**&amp;lt;/b&amp;gt;&amp;lt;br&amp;gt;
 Comparing &amp;lt;span style = &amp;#39;color:#DE0100;font-size:24pt&amp;#39;&amp;gt;**Donald J. Trump**&amp;lt;/span&amp;gt; &amp;amp; &amp;lt;span style = &amp;#39;color:#0015BC;font-size:24pt&amp;#39;&amp;gt;**Joe R. Biden**&amp;lt;/span&amp;gt;&amp;quot;, 
  x = &amp;#39;USDA Rural-Urban\nContinuum 2013&amp;#39;, 
  y = &amp;#39;Total Votes&amp;#39;, 
 caption = &amp;#39;Original data are from New York Times API.\nParsed by Fabio Votta (@favstats), and downloaded from https://github.com/favstats/USElection2020-NYT-Results.\nCreated by Elliot Meador (@Elliot_Meador).&amp;#39;) +
      post_theme(
        axis.text.y = element_markdown(),
        plot.title.position = &amp;quot;plot&amp;quot;,
        plot.title = element_textbox_simple(
            size = 18,
            lineheight = 1,
            padding = margin(5.5, 5.5, 5.5, 5.5),
            margin = margin(0, 0, 5.5, 0), 
    ),
    plot.margin = margin(2,2,2,2, &amp;#39;cm&amp;#39;)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-11-08-us-2020-presidental-election-and-rural-urban-divide.en_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;960&#34; /&gt;
We can revisit our initial research questions and see that within rural areas there really isn’t enough people there to swing a national election.
Also, Trump won over 40% of the big metro areas in the US, and even higher in some urban areas.
More research is needed, but I personally don’t buy the argument that Trumps’ supporters are contained in rural areas only whilst Biden’s are found in the urban centres.
On the contrary, it a much more mixed bag for both parties.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>U.S. Food Deserts</title>
      <link>/post/food-deserts-data-clean-merge/</link>
      <pubDate>Sun, 16 Aug 2020 00:00:00 +0000</pubDate>
      <guid>/post/food-deserts-data-clean-merge/</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/kePrint/kePrint.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/htmlwidgets/htmlwidgets.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/pymjs/pym.v1.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/widgetframe-binding/widgetframe.js&#34;&gt;&lt;/script&gt;


&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;A considerable issue today related to food and rural population research are food deserts.
Food deserts are a complicated issue, but the idea centres on a simple premise: areas, where it’s hard to reach a grocery store or access food, can be thought of as food deserts.
If you’re interested in knowing more about the discourse on food deserts, I’d recommend looking into these papers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Blanchard, T. C., &amp;amp; Matthews, T. L. (2007). Retail concentration, food deserts, and food-disadvantaged communities in rural America. Remaking the North American food system: &lt;em&gt;Strategies for sustainability&lt;/em&gt;, 201-215.&lt;/li&gt;
&lt;li&gt;Gundersen, C., Kreider, B., &amp;amp; Pepper, J. V. (2017). Partial identification methods for evaluating food assistance programs: a case study of the causal impact of SNAP on food insecurity. &lt;em&gt;American Journal of Agricultural Economics&lt;/em&gt;, 99(4), 875-893.&lt;/li&gt;
&lt;li&gt;Andrews, M., Bhatta, R., &amp;amp; Ploeg, M. V. (2013). An alternative to developing stores in food deserts: can changes in SNAP benefits make a difference?. &lt;em&gt;Applied Economic Perspectives and Policy&lt;/em&gt;, 35(1), 150-170.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;the-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;The data&lt;/h1&gt;
&lt;p&gt;Data for this post is on food deserts and comes from Kaggle.
Kaggle is an excellent resource for aspiring data scientists and experienced ones.
Specifically, the page called &lt;a href=&#34;https://www.kaggle.com/tcrammond/food-access-and-food-deserts?select=food_access_variable_lookup.csv&#34;&gt;Food Deserts in the US: Food access for sub-populations of the United States&lt;/a&gt;.
You can download the data directly from the link in the sentence above.
The code below reads in the data.&lt;/p&gt;
&lt;div id=&#34;libraries-and-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Libraries and data&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# For data wrangling/tables
library(tidyverse)
library(janitor)
library(knitr)
library(kableExtra)
library(glue)
library(tidytext)
library(scales)

# For mapping and census data
library(tigris)
library(leaflet)
library(leaflet.extras)
library(maps)
library(sf)
library(widgetframe)
library(htmlwidgets)
library(htmltools)
map &amp;lt;- purrr::map

# US county and state fips data is built-in R
data(&amp;quot;county.fips&amp;quot;)
county.fips &amp;lt;- 
 county.fips %&amp;gt;% 
  as_tibble()

data(&amp;quot;state.fips&amp;quot;)
state.fips &amp;lt;- 
  state.fips %&amp;gt;% 
  as_tibble()


# File 1
food_access_research_atlas &amp;lt;- 
  read_csv(&amp;#39;~/Downloads/665808_1173338_bundle_archive/food_access_research_atlas.csv&amp;#39;) %&amp;gt;% 
  clean_names()

# File 2
lookup &amp;lt;- 
  read_csv(&amp;#39;~/Downloads/665808_1173338_bundle_archive/food_access_variable_lookup.csv&amp;#39;) %&amp;gt;% 
  clean_names()

# Pull in the USDA data from a directory I created in my cloud storage.
rural_urban &amp;lt;-
  read_csv(&amp;#39;~/OneDrive - SRUC/Data/usda/ruralurbancodes2013.csv&amp;#39;) %&amp;gt;%
  select(state, 
         county = county_name,
         rucc_2013,
         desc = description)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;theme&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Theme&lt;/h2&gt;
&lt;p&gt;We’ll use a custom theme for &lt;code&gt;ggplot2&lt;/code&gt; plots made with this code.
Note the &lt;code&gt;...&lt;/code&gt; notation, which allows us to make on-the-fly changes without calling another &lt;code&gt;theme&lt;/code&gt; argument.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# a custom theme for ggplots
post_theme &amp;lt;- function(...) {
  theme(
    text = 
      element_text(
        color = &amp;#39;black&amp;#39;,
         family = &amp;#39;serif&amp;#39;),
    axis.text = 
      element_text(
        color = &amp;#39;black&amp;#39;, 
        size = 12.5),
    panel.background = 
      element_blank(),
    axis.line.x = 
      element_line(
        color = &amp;#39;black&amp;#39;),
    axis.ticks = element_blank(),
    plot.margin = margin(.75, .75, .75, .75, &amp;#39;cm&amp;#39;),
    plot.caption = 
      element_text(hjust = 0,
                                face = &amp;quot;italic&amp;quot;),
    plot.title = 
      element_text(
        face = &amp;#39;bold&amp;#39;),
    plot.subtitle = 
      element_text(face = &amp;#39;bold&amp;#39;),
    plot.title.position = &amp;quot;plot&amp;quot;,
    plot.caption.position =  &amp;quot;plot&amp;quot;, 
    strip.background = 
      element_blank(), 
    strip.text = 
      element_text(
        face = &amp;#39;bold&amp;#39;)
  ) +
    theme(...) # this bit allows us to make changes using this same function instead of calling two theme functions.
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An exciting caveat with the data is that it comes in two files.
One file is the data, and the other file is what’s known as a data dictionary or data lookup.
The lookup file is a database that explains what each variable is.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;linking-with-rural-urban-classification-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Linking with rural-urban classification data&lt;/h2&gt;
&lt;p&gt;There isn’t a perfect indicator of rural/urban classification in the data, so, as usual, we’ll need to add one.
I’ve used the USDA Rural-Urban Classifications before in the post on &lt;a href=&#34;https://www.thedeltanomics.com/post/covid-19-rural-deltanomics/&#34;&gt;Covid-19 and Rural Areas in the U.S.&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# clean names will be used to help get joining data in format that will merge well
clean_names &amp;lt;- 
  function(x){
    x &amp;lt;- str_to_lower(x)
    x &amp;lt;- str_remove_all(x, &amp;#39;county&amp;#39;)
    x &amp;lt;- str_remove_all(x, &amp;#39;[[:digit:]]&amp;#39;)
    x &amp;lt;- str_squish(x)
    x &amp;lt;- str_trim(x)
    x
  }

rural_urban &amp;lt;- 
  rural_urban %&amp;gt;% 
  mutate(county = clean_names(county)) %&amp;gt;% 
  rename(abb = state) %&amp;gt;% 
  left_join(
tibble(abb = state.abb, 
       state = clean_names(state.name)),
       by = &amp;quot;abb&amp;quot;) %&amp;gt;% 
  mutate(state_county = 
           glue(&amp;#39;{state} {county}&amp;#39;)) %&amp;gt;% 
  select(state_county, rucc_2013, desc)

rural_food_desert &amp;lt;- 
  food_access_research_atlas %&amp;gt;% 
  mutate(state = clean_names(state),
            county = clean_names(county),
            state_county = 
                  glue(&amp;#39;{state} {county}&amp;#39;)) %&amp;gt;% 
  left_join(rural_urban, 
            by = &amp;#39;state_county&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;working-with-lookup-files---a-closer-look-at-snap&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Working with lookup files - A closer look at SNAP&lt;/h1&gt;
&lt;p&gt;Lookup files are often called &lt;em&gt;data dictionaries&lt;/em&gt;.
Data dictionaries are a common component of many large datasets that are used extensively in the public sphere.
As previously mentioned, quite often, a data dictionary or lookup is just another file that accompanies the primary data.&lt;/p&gt;
&lt;p&gt;The data dictionary isn’t “data” in the traditional sense (i.e. we aren’t going to be performing cross-tabulations on it anytime soon), but it is a useful approach to treat it just like any other data file.
For instance:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;We can append data dictionaries/lookups to the central database as we did previously;&lt;/li&gt;
&lt;li&gt;We can use natural language processing on the data dictionaries to get a better understanding of the data holds; and,&lt;/li&gt;
&lt;li&gt;We can use data tools like &lt;code&gt;dplyr&lt;/code&gt; and &lt;code&gt;purrr&lt;/code&gt; to pick apart the lookup file and make it more manageable.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let’s say we are interested in looking at SNAP.
SNAP is short for &lt;em&gt;Supplemental Nutrition Assistance Program&lt;/em&gt;.
According to the &lt;a href=&#34;https://www.fns.usda.gov/snap/supplemental-nutrition-assistance-program&#34;&gt;USDA’s website&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SNAP provides nutrition benefits to supplement the food budget of needy families so they can purchase healthy food and move towards self-sufficiency.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We can use &lt;code&gt;dplyr&lt;/code&gt; and the &lt;code&gt;kable&lt;/code&gt; function from &lt;code&gt;knitr&lt;/code&gt; to quickly search and display the results for variables on SNAP.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lookup %&amp;gt;% 
  filter(str_detect(description, &amp;#39;SNAP&amp;#39;)) %&amp;gt;% 
  mutate(long_name = 
           str_trunc(long_name, 10)) %&amp;gt;% 
  kable(format = &amp;#39;html&amp;#39;, booktab = T) %&amp;gt;% 
  kable_styling()&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table&#34; style=&#34;margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
field
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
long_name
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
description
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
lasnaphalf
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Low acc…
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Housing units receiving SNAP benefits count beyond 1/2 mile from supermarket
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
lasnaphalfshare
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Low acc…
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Share of tract housing units receiving SNAP benefits count beyond 1/2 mile from supermarket
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
lasnap1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Low acc…
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Housing units receiving SNAP benefits count beyond 1 mile from supermarket
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
lasnap1share
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Low acc…
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Share of tract housing units receiving SNAP benefits count beyond 1 mile from supermarket
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
lasnap10
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Low acc…
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Housing units receiving SNAP benefits count beyond 10 miles from supermarket
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
lasnap10share
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Low acc…
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Share of tract housing units receiving SNAP benefits count beyond 10 miles from supermarket
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
lasnap20
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Low acc…
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Housing units receiving SNAP benefits count beyond 20 miles from supermarket
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
lasnap20share
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Low acc…
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Share of tract housing units receiving SNAP benefits count beyond 20 miles from supermarket
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
TractSNAP
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tract h…
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Total count of housing units receiving SNAP benefits in tract
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Glancing at the table above, one will quickly see nine variables cover SNAP benefits.
Also, it appears that SNAP variables are often distinguished by have either &lt;em&gt;number&lt;/em&gt; or &lt;em&gt;share&lt;/em&gt;, which means that the variable has either total counts of percents of occurrence.&lt;/p&gt;
&lt;p&gt;Let’s take a look at some and compare them by state.
We’ll use the verb &lt;code&gt;contains&lt;/code&gt; within &lt;code&gt;dyplyr&lt;/code&gt; to grab variables contain &lt;em&gt;SNAP&lt;/em&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rural_food_desert_snap &amp;lt;- 
  rural_food_desert %&amp;gt;% 
  select(state, county, desc, census_tract, median_family_income,
         contains(&amp;#39;snap&amp;#39;)) &lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;getting-things-tidy&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Getting things tidy&lt;/h1&gt;
&lt;p&gt;Before going forward we’ll need to tidy our data a bit.
Note the use of &lt;code&gt;pivot_longer&lt;/code&gt; instead of &lt;code&gt;spread&lt;/code&gt;; &lt;code&gt;pivot_longer&lt;/code&gt; and &lt;code&gt;pivot_wider&lt;/code&gt; are &lt;code&gt;dplyr&lt;/code&gt;’s new verb names for changing between wide and long formats.
We won’t discuss the major changes here, but it’s good practice to read over big changes like this; you can do so &lt;a href=&#34;https://cengel.github.io/R-data-wrangling/tidyr.html&#34;&gt;here&lt;/a&gt;.
Once we have our data in a way that we like it let’s do some quick plots, first looking at state and county levels, then looking at rural-urban areas.&lt;/p&gt;
&lt;div id=&#34;travel-distance&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Travel distance&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;county_snap_dist &amp;lt;-
  rural_food_desert_snap %&amp;gt;% 
  mutate(id = group_indices(., census_tract)) %&amp;gt;%
  select(state, 
         county, 
         desc,
         median_family_income,
         census_tract,
         contains(&amp;#39;share&amp;#39;)) %&amp;gt;% 
  pivot_longer(-c(state, 
                  county, 
                  desc, 
                  census_tract,
                  median_family_income),
               names_to =  &amp;#39;snap_dist&amp;#39;, 
               values_to = &amp;#39;rate&amp;#39;) %&amp;gt;% 
  mutate(snap_dist = 
           parse_number(snap_dist), 
         snap_dist = 
           replace_na(snap_dist, .5)) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s quickly take a look at the top rate (percent) of people in census tracts for each distance from a supermarket.
In addition, we’ll consider the association between rate of SNAP recipients to income.&lt;/p&gt;
&lt;p&gt;The plot below uses the &lt;code&gt;stat_binhex&lt;/code&gt; in ggplot.
This approach is similar to a standard scatter plot, but it shows which areas of the plot have the highest frequency. This is important as the plot will have 124,326 points - far too many for a person to visual see the difference (due to overlapping with the points).
The &lt;code&gt;stat_binhex&lt;/code&gt; function uses colour to differentiate the frequencies for each bin.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;label_new &amp;lt;- 
  function(x){
    glue(&amp;#39;{x} miles to\nnearest supermarket&amp;#39;)
  }

county_snap_dist %&amp;gt;% 
  mutate(snap_dist = as.factor(snap_dist),
         snap_dist = fct_relabel(snap_dist, 
                                 .fun = label_new)) %&amp;gt;% 
  filter(rate &amp;gt; 0) %&amp;gt;% 
  ggplot(aes(median_family_income, rate))+
  stat_binhex()+
  geom_smooth(color = &amp;#39;#CCCCCC&amp;#39;, 
              method = &amp;#39;gam&amp;#39;)+
  scale_fill_viridis_c(labels = comma, 
                       name = &amp;#39;# of\ncensus tracts&amp;#39;)+
  scale_x_continuous(labels = dollar)+
  scale_y_continuous(labels = percent, 
                     expand = c(0, 0))+
  facet_grid(~snap_dist, )+
  post_theme(axis.text.x = element_text(angle = 45, 
                                        hjust = 1))+
    labs(title = &amp;#39;Association between SNAP rate and family income by travel distance to supermarket&amp;#39;, 
         x = &amp;#39;Median family income\nper census tract&amp;#39;, 
         y = &amp;#39;Percent SNAP\nrecipient&amp;#39;, 
        caption = &amp;#39;Smoothed line fits a generalized additive model (GAM) to data: y ~ s(x, bs = &amp;quot;cs&amp;quot;).&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-07-29-u-s-food-deserts_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;960&#34; /&gt;
According to plot above, we can see that there is a relationship between median family income and percentage of SNAP usage.
Interestingly, but ultimately out of scope for this project, is the high percentage of SNAP recievers in places with high median family income values ($100k or more).
We see this because both SNAP and median family income are measurements of central tendency within a geography.
They are not 1-to-1 comparisons.
That is, we aren’t looking at survey data completed by individual people.
This finding alone tells us that it is necessary to look deeper into SNAP, as families who recieve the benefit may live quite unique lives, each with their own struggles to overcome.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;building-interactive-maps&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Building interactive maps&lt;/h1&gt;
&lt;p&gt;Our data is aggregated by census tract and is therefore geographical by nature.
Mapping in R has made considerable developments in the past 5 to 10 years, and any work with rural/urban analysis can usually be benefited through some geospatial analysis.
So learning to make maps is always helpful!&lt;/p&gt;
&lt;div id=&#34;leaflet-maps&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Leaflet maps&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;leaflet&lt;/code&gt; package is a fantastic way to make interactive maps with a relatively small amount of code.
It works really well will with the &lt;code&gt;sf&lt;/code&gt; package for geo-computational analysis.
Moreover, we can use the &lt;code&gt;tigris&lt;/code&gt; package to get census tract information straight in R.
&lt;code&gt;tigris&lt;/code&gt; can return &lt;code&gt;sf&lt;/code&gt; objects, making for speedy workflow between the three packages.&lt;/p&gt;
&lt;p&gt;Below, we’ll take a look those census tracts that have a large proportion of the population that have to travel 20 or miles to a supermarket and that have a high percentage of SNAP recipients.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## Get all 20 miles or more that have at least some percent of SNAP users
top_perc_20m &amp;lt;- 
  county_snap_dist %&amp;gt;% 
  filter(snap_dist == 20, 
         rate &amp;gt; 0) %&amp;gt;% 
  mutate(desc = replace_na(desc, &amp;#39;Unknown&amp;#39;))


top_perc_20m_ls &amp;lt;- 
  top_perc_20m %&amp;gt;% 
  mutate(id = as.character(row_number())) %&amp;gt;% 
  split(.$id)


# retrieve all census tract polygons per county using a loop and the applying the tracts function from the tigris package.

top_perc_20_sf_ls &amp;lt;- 
  map(top_perc_20m_ls, 
      possibly(function(x){
        .y &amp;lt;-   tracts(state = x$state, 
                       county = x$county, 
                       cb = T) 
        
        single_track &amp;lt;- 
          str_sub(x$census_tract,
                start = 6, 
                end = 9)
        
        .z &amp;lt;- .y %&amp;gt;% 
          filter(NAME %in% single_track)
        
        .z$census_tract &amp;lt;- x$census_tract
        .z$rate &amp;lt;- x$rate
        .z$dist &amp;lt;- x$snap_dist
        .z$desc &amp;lt;- x$desc
        .z$id &amp;lt;-  x$id
        .z$county &amp;lt;-  x$county
        .z$state &amp;lt;-  x$state
       .z$median_family_income &amp;lt;-x$median_family_income
        
        return(.z)
        
      }, NULL)) 

# NOTE do.call to combine the sf objects
top_20_sf &amp;lt;- 
  do.call(rbind,top_perc_20_sf_ls) 

# This whole code-block may take quite a bit of time to run depending on your computer&amp;#39;s specs. It&amp;#39;s best to go ahead and save the output and then comment out the code above. This reduces the risk of accidently changing or re-running things, then having to wait to make adjustments. 

write_sf(top_20_sf,&amp;#39;~/Documents/temp/top_20_sf.shp&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It only takes a few lines of code to produce a great map in &lt;code&gt;leaflet&lt;/code&gt;.
Below you can see the polygons of the top 25 SNAP recipients in food deserts that are 20 miles or more to supermarkets.
And, while it is inciteful in its own right, it leaves us wanting something more.
With the help of &lt;code&gt;HTML&lt;/code&gt;, we can turn this map into something fantastic!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;leaflet(top_20_sf) %&amp;gt;% 
  addProviderTiles(&amp;quot;CartoDB.Positron&amp;quot;) %&amp;gt;% 
  addPolygons(color = &amp;quot;tomato&amp;quot;) %&amp;gt;% 
  frameWidget()&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;htmlwidget-1&#34; style=&#34;width:100%;height:480px;&#34; class=&#34;widgetframe html-widget&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;htmlwidget-1&#34;&gt;{&#34;x&#34;:{&#34;url&#34;:&#34;/post/2020-07-29-u-s-food-deserts_files/figure-html//widgets/widget_unnamed-chunk-11.html&#34;,&#34;options&#34;:{&#34;xdomain&#34;:&#34;*&#34;,&#34;allowfullscreen&#34;:false,&#34;lazyload&#34;:false}},&#34;evals&#34;:[],&#34;jsHooks&#34;:[]}&lt;/script&gt;
&lt;div id=&#34;leaflet-to-the-next-level&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Leaflet to the next level&lt;/h3&gt;
&lt;p&gt;One way to dramatically improve our interactive &lt;code&gt;leaflet&lt;/code&gt; maps is to use &lt;code&gt;HTML&lt;/code&gt; code. &lt;code&gt;HTML&lt;/code&gt; is essential a coding approach to formatting web applications.
Officially &lt;code&gt;HTML&lt;/code&gt; is:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hypertext Markup Language (HTML) is the standard markup language for documents designed to be displayed in a web browser. It can be assisted by technologies such as Cascading Style Sheets (CSS) and scripting languages such as JavaScript.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We’ll also use &lt;code&gt;CSS&lt;/code&gt;, which is similar to &lt;code&gt;HTML&lt;/code&gt; in that it’s used to format websites. Officially, &lt;code&gt;CSS&lt;/code&gt; is:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CSS stands for Cascading Style Sheets. CSS describes how HTML elements are to be displayed on screen, paper, or in other media. CSS saves a lot of work. It can control the layout of multiple web pages all at once. External stylesheets are stored in CSS files.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We can also use our data to correspond to map polygon colours.
The &lt;code&gt;leaflet.extras&lt;/code&gt; package offers a lot of great extra options to add to &lt;code&gt;leaflet&lt;/code&gt; maps.
The best part is that it is relatively straightforward to add these options.&lt;/p&gt;
&lt;p&gt;Let’s take the following steps to &lt;em&gt;trick&lt;/em&gt; out our &lt;code&gt;leaflet&lt;/code&gt; map!&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;We’ll use &lt;code&gt;HTML&lt;/code&gt; to create some tooltips that provide users information when they hover over polygons in the map.&lt;/li&gt;
&lt;li&gt;Create a custom function to map the fill/colour of the &lt;code&gt;leaflet&lt;/code&gt; polygons to help guide the user’s eye towards the worst off places in terms of SNAP and distance to supermarket.
NOTE: Our custom colour function is from &lt;a href=&#34;https://stackoverflow.com/questions/15006211/how-do-i-generate-a-mapping-from-numbers-to-colors-in-r/18749392&#34;&gt;this question on StackOverflow.com&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;leaflet.extras&lt;/code&gt; to add some great functionality that makes the map more user-friendly.&lt;/li&gt;
&lt;li&gt;Create and format a title using CSS.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;remove_words &amp;lt;- 
  glue_collapse(c(&amp;#39;Nonmetro - &amp;#39;, 
                  &amp;#39;Metro - &amp;#39;),&amp;#39;|&amp;#39;)

## tooltip with html
tooltip &amp;lt;- top_20_sf %&amp;gt;% 
  as_tibble() %&amp;gt;% 
  mutate(county = str_to_title(county), 
         state = str_to_title(state), 
         rate = round(rate, 2),
         rate = percent(rate), 
         desc = str_remove_all(desc,
                               remove_words), 
         median_family_income = 
           dollar(median_family_income)) %&amp;gt;% 
  transmute(tip = glue(&amp;#39;&amp;lt;b&amp;gt;County:&amp;lt;/b&amp;gt; {county} &amp;lt;br&amp;gt; &amp;lt;b&amp;gt;State:&amp;lt;/b&amp;gt; {state} &amp;lt;br&amp;gt; &amp;lt;b&amp;gt;*SNAP percent:&amp;lt;/b&amp;gt; {rate} &amp;lt;br&amp;gt; &amp;lt;b&amp;gt;**Rural/Urban class:&amp;lt;/b&amp;gt; {desc} &amp;lt;br&amp;gt; &amp;lt;b&amp;gt;Median family income:&amp;lt;/b&amp;gt; {median_family_income} &amp;lt;br&amp;gt;&amp;lt;b&amp;gt;Tract:&amp;lt;/b&amp;gt; {census_tract}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;* All areas have this percentage SNAP recipients who 20 or more miles from a supermarket.&amp;lt;br&amp;gt;** Rural/Urban classification determined at county-level.&amp;#39;))

# change polygon colour to correspond to a numeric variable in the database
map2color &amp;lt;- function(x, 
                      pal, 
                      limits = NULL) {
  if (is.null(limits))
    limits = range(x)
  pal[findInterval(x, 
               seq(limits[1], 
               limits[2], 
               length.out = length(pal) + 1), 
                   all.inside = TRUE)]
}

col_pal &amp;lt;- rev(viridis_pal()(6))

all_rate &amp;lt;- top_20_sf %&amp;gt;% 
  as_tibble() %&amp;gt;% 
  pull(rate) 

all_rate_0 &amp;lt;- 
  ifelse(all_rate &amp;lt; 0.005, 0, all_rate)

all_rate_6 &amp;lt;- cut_interval(all_rate_0, 
                           6, 
                           labels = F) 

percent_labs &amp;lt;- c(&amp;#39;0.0% to 10.1%&amp;#39;, 
  &amp;#39;10.1% to 20.2%&amp;#39;,
  &amp;#39;20.2% to 30.2%&amp;#39;,
  &amp;#39;30.2% to 40.3%&amp;#39;,
  &amp;#39;40.3% to 50.4%&amp;#39;,
  &amp;#39;50.4% to 60.5%&amp;#39;)

## Add a our title to the map using css

tag.map.title &amp;lt;- tags$style(HTML(&amp;quot;
  .leaflet-control.map-title { 
    transform: translate(-50%,20%);
    position: fixed !important;
    left: 50%;
    text-align: center;
    padding-left: 10px; 
    padding-right: 10px; 
    background: rgba(255,255,255,0.5);
    font-weight: bold;
    font-size: 28px;
  }
&amp;quot;))

title &amp;lt;- tags$div(
  tag.map.title, HTML(&amp;quot;US Food Deserts&amp;quot;)
)  



top_20_sf_leaf_map &amp;lt;- 
    leaflet(top_20_sf) %&amp;gt;% 
  addProviderTiles(&amp;quot;OpenStreetMap&amp;quot;) %&amp;gt;%
  addPolygons(color = &amp;#39;#C4C4C4&amp;#39;,
              fillColor  = 
                map2color(all_rate_6, 
                          col_pal), 
              fillOpacity = .85,
              weight = .55,
              popup = tooltip$tip, 
          opacity = 1
          )%&amp;gt;%
  addDrawToolbar(
    editOptions=editToolbarOptions(selectedPathOptions=selectedPathOptions())
  ) %&amp;gt;%
  addLegend(colors = col_pal, 
            labels = percent_labs, 
            opacity = 0.7,
            title = &amp;#39;Percent SNAP use&amp;lt;br&amp;gt;by census tract&amp;#39;,
    position = &amp;quot;bottomright&amp;quot;) %&amp;gt;%
  addControl(title, 
             position = &amp;quot;topleft&amp;quot;,
             className=&amp;quot;map-title&amp;quot;)

top_20_sf_leaf_map %&amp;gt;% 
  frameWidget(width = &amp;#39;100%&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;div id=&#34;htmlwidget-2&#34; style=&#34;width:100%;height:480px;&#34; class=&#34;widgetframe html-widget&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;htmlwidget-2&#34;&gt;{&#34;x&#34;:{&#34;url&#34;:&#34;/post/2020-07-29-u-s-food-deserts_files/figure-html//widgets/widget_unnamed-chunk-12.html&#34;,&#34;options&#34;:{&#34;xdomain&#34;:&#34;*&#34;,&#34;allowfullscreen&#34;:false,&#34;lazyload&#34;:false}},&#34;evals&#34;:[],&#34;jsHooks&#34;:[]}&lt;/script&gt;
Our &lt;code&gt;leaflet&lt;/code&gt; map now has plenty of bells and whistles, and hopefully, it will be useful for people interested in knowing more about food deserts and SNAP in the US.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Food deserts and SNAP are complicated subjects in their own right.
Very often, the two compound one another, making things even more complicated.
Using data science approaches to thinking about these two issues can help policymakers and rural stakeholders better plan for those people impacted by them.&lt;/p&gt;
&lt;p&gt;As always, the &lt;em&gt;Deltanomics&lt;/em&gt; blog is for instructional use in R.
Any potential findings need more research to verify them before any conclusions can be made.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
